
# Promise
## 背景
- 同步编程，易于理解，易于编写；耗时的同步函数运行时，程序将无法做任何事情
- 异步编程，解决同步耗时函数产生的问题，通过
  1. 调用一个函数启动长期运行的操作
  2. 让函数开始操作并立即返回，这样程序就可以对其他事件做出处理
  3. 当操作完成时，通知我们操作的结果
## 发展
- 回调函数，被传入另一个函数中的会在适当的时候被调用的函数
- 缺点，等存在多重回调时，出现'回调地狱':
  1. 难以阅读和调试，
  2. 处理错误变的非常困难
  3. 必须在每一级处理错误，而不是在最高级一次性处理

## 优化
引入Promise对象，代表一个异步操作的最终结果，完成或失败
>由异步函数返回的可以向我们指示当前操作所处的状态的对象。在 Promise 返回给调用者的时候，操作往往还没有完成，但 Promise 对象可以让我们操作最终完成时对其进行处理（无论成功还是失败）。

- 一个Promise必然处于以下三种状态
  1. 初始
  2. 成功
  3. 失败

- 可以将异步操作最终结果和响应的处理程序关联起来
  1. 通过 then 链式调用,避免代码的层层嵌套
  2. 通过 catch 一次性处理异常
  3. 通过 finally 执行一些清理操作

async 和 await 
- 基于 promise 的语法糖，使异步编程，更加简洁明了
- async 关键字，将函数标记为异步函数--返回值为 promise 对象的函数
- await 异步函数中，调用其他异步函数的关键字，会等待promise完成后，直接返回最终的结果
- await 看上去会暂停函数的执行，等待的过程中，js同样可以处理其他任务
- await 陷阱
  1. 多个await的并行，需要使用 Promise.all
  2. map和forEach中的await 无效，需要使用for
  3. 循环的并发执行，需要使用 for await

### 待补充 await底层 基于Promise 和 事件循环机制